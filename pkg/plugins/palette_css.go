package plugins

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/WaylonWalker/markata-go/pkg/lifecycle"
	"github.com/WaylonWalker/markata-go/pkg/palettes"
)

// PaletteCSSPlugin generates CSS variables from the configured color palette.
// It runs during the Write stage and creates/overwrites css/variables.css
// with the palette's CSS custom properties. It runs after static_assets
// to overwrite the default variables.css with palette-specific values.
//
// The plugin supports intelligent light/dark palette mapping:
// - palette = "everforest" will auto-detect everforest-light and everforest-dark
// - palette_light and palette_dark can override the auto-detected variants
//
// The plugin maps palette colors to the theme's expected CSS variable names,
// preserving fonts, spacing, and other non-color variables from the default theme.
type PaletteCSSPlugin struct{}

// NewPaletteCSSPlugin creates a new PaletteCSSPlugin.
func NewPaletteCSSPlugin() *PaletteCSSPlugin {
	return &PaletteCSSPlugin{}
}

// Name returns the unique name of the plugin.
func (p *PaletteCSSPlugin) Name() string {
	return "palette_css"
}

// Write generates CSS from the configured palette and writes it to the output directory.
func (p *PaletteCSSPlugin) Write(m *lifecycle.Manager) error {
	config := m.Config()
	outputDir := config.OutputDir

	// Get palette configuration from config.Extra["theme"]
	paletteName, paletteLight, paletteDark := p.getPaletteConfig(config.Extra)
	if paletteName == "" {
		// No palette configured, skip
		return nil
	}

	// Get effective light and dark palette names
	lightName, darkName := palettes.GetEffectivePalettes(paletteName, paletteLight, paletteDark)

	// Load palettes
	loader := palettes.NewLoader()

	var lightPalette, darkPalette *palettes.Palette
	var err error

	// Load light palette
	if lightName != "" {
		lightPalette, err = loader.Load(lightName)
		if err != nil {
			// Fall back to base palette
			lightPalette, err = loader.Load(paletteName)
			if err != nil {
				return fmt.Errorf("loading light palette %q: %w", lightName, err)
			}
		}
	}

	// Load dark palette
	if darkName != "" {
		darkPalette, err = loader.Load(darkName)
		if err != nil {
			// Fall back to base palette
			darkPalette, err = loader.Load(paletteName)
			if err != nil {
				return fmt.Errorf("loading dark palette %q: %w", darkName, err)
			}
		}
	}

	// If we have no palettes loaded, try to load the base palette
	if lightPalette == nil && darkPalette == nil {
		palette, err := loader.Load(paletteName)
		if err != nil {
			return fmt.Errorf("loading palette %q: %w", paletteName, err)
		}
		lightPalette = palette
		darkPalette = palette
	}

	// Generate theme-compatible CSS with both variants
	css := p.generateThemeCSSWithVariants(lightPalette, darkPalette, lightName, darkName)

	// Write to output directory
	cssDir := filepath.Join(outputDir, "css")
	if err := os.MkdirAll(cssDir, 0o755); err != nil {
		return fmt.Errorf("creating css directory: %w", err)
	}

	cssPath := filepath.Join(cssDir, "variables.css")
	//nolint:gosec // G306: variables.css is a public CSS file, 0644 is appropriate
	if err := os.WriteFile(cssPath, []byte(css), 0o644); err != nil {
		return fmt.Errorf("writing palette CSS: %w", err)
	}

	return nil
}

// generateThemeCSSWithVariants generates CSS with both light and dark palette variants.
// The CSS uses data-theme attribute for switching between variants.
func (p *PaletteCSSPlugin) generateThemeCSSWithVariants(lightPalette, darkPalette *palettes.Palette, lightName, darkName string) string {
	var buf bytes.Buffer

	// Header comment
	buf.WriteString("/* CSS Custom Properties - Generated by markata-go */\n")
	buf.WriteString(fmt.Sprintf("/* Light: %s, Dark: %s */\n\n", lightName, darkName))

	// Generate palette info CSS custom properties for JavaScript
	buf.WriteString("/* Palette configuration for JavaScript theme toggle */\n")
	buf.WriteString(":root {\n")
	// CSS custom property values need the quotes as part of the value for JS to read
	buf.WriteString(fmt.Sprintf("  --palette-light: %q;\n", lightName))
	buf.WriteString(fmt.Sprintf("  --palette-dark: %q;\n", darkName))
	buf.WriteString("}\n\n")

	// Generate light mode (default) styles
	if lightPalette != nil {
		buf.WriteString(fmt.Sprintf("/* Light mode - %s */\n", lightPalette.Name))
		buf.WriteString(":root,\n")
		buf.WriteString("[data-theme=\"light\"] {\n")
		p.writePaletteVariables(&buf, lightPalette)
		buf.WriteString("}\n\n")
	}

	// Generate dark mode styles
	if darkPalette != nil {
		buf.WriteString(fmt.Sprintf("/* Dark mode - %s */\n", darkPalette.Name))
		buf.WriteString("[data-theme=\"dark\"] {\n")
		p.writePaletteVariables(&buf, darkPalette)
		buf.WriteString("}\n\n")

		// Also add prefers-color-scheme media query for auto mode
		buf.WriteString("/* Auto dark mode based on system preference */\n")
		buf.WriteString("@media (prefers-color-scheme: dark) {\n")
		buf.WriteString("  :root:not([data-theme=\"light\"]) {\n")
		p.writePaletteVariablesIndented(&buf, darkPalette, "    ")
		buf.WriteString("  }\n")
		buf.WriteString("}\n")
	}

	return buf.String()
}

// writePaletteVariables writes CSS custom properties for a palette.
func (p *PaletteCSSPlugin) writePaletteVariables(buf *bytes.Buffer, palette *palettes.Palette) {
	p.writePaletteVariablesIndented(buf, palette, "  ")
}

// writePaletteVariablesIndented writes CSS custom properties with custom indentation.
//
//nolint:gocyclo // complexity is acceptable for a CSS generation function with many rules
func (p *PaletteCSSPlugin) writePaletteVariablesIndented(buf *bytes.Buffer, palette *palettes.Palette, indent string) {
	// Primary/accent colors
	if accent := palette.Resolve("accent"); accent != "" {
		fmt.Fprintf(buf, "%s--color-primary: %s;\n", indent, accent)
	}
	if accentHover := palette.Resolve("accent-hover"); accentHover != "" {
		fmt.Fprintf(buf, "%s--color-primary-light: %s;\n", indent, accentHover)
		fmt.Fprintf(buf, "%s--color-primary-dark: %s;\n", indent, accentHover)
	}

	fmt.Fprintf(buf, "\n%s/* Semantic colors */\n", indent)

	// Text colors
	if textPrimary := palette.Resolve("text-primary"); textPrimary != "" {
		fmt.Fprintf(buf, "%s--color-text: %s;\n", indent, textPrimary)
	}
	if textMuted := palette.Resolve("text-muted"); textMuted != "" {
		fmt.Fprintf(buf, "%s--color-text-muted: %s;\n", indent, textMuted)
	}

	// Background colors
	if bgPrimary := palette.Resolve("bg-primary"); bgPrimary != "" {
		fmt.Fprintf(buf, "%s--color-background: %s;\n", indent, bgPrimary)
	}
	if bgSurface := palette.Resolve("bg-surface"); bgSurface != "" {
		fmt.Fprintf(buf, "%s--color-surface: %s;\n", indent, bgSurface)
	}

	// Border
	if border := palette.Resolve("border"); border != "" {
		fmt.Fprintf(buf, "%s--color-border: %s;\n", indent, border)
	}

	fmt.Fprintf(buf, "\n%s/* Status colors */\n", indent)

	// Status colors
	if success := palette.Resolve("success"); success != "" {
		fmt.Fprintf(buf, "%s--color-success: %s;\n", indent, success)
	}
	if warning := palette.Resolve("warning"); warning != "" {
		fmt.Fprintf(buf, "%s--color-warning: %s;\n", indent, warning)
	}
	if errorColor := palette.Resolve("error"); errorColor != "" {
		fmt.Fprintf(buf, "%s--color-error: %s;\n", indent, errorColor)
	}
	if info := palette.Resolve("info"); info != "" {
		fmt.Fprintf(buf, "%s--color-info: %s;\n", indent, info)
	}

	// Add link colors if available
	if link := palette.Resolve("link"); link != "" {
		fmt.Fprintf(buf, "\n%s/* Link colors */\n", indent)
		fmt.Fprintf(buf, "%s--color-link: %s;\n", indent, link)
		if linkHover := palette.Resolve("link-hover"); linkHover != "" {
			fmt.Fprintf(buf, "%s--color-link-hover: %s;\n", indent, linkHover)
		}
		if linkVisited := palette.Resolve("link-visited"); linkVisited != "" {
			fmt.Fprintf(buf, "%s--color-link-visited: %s;\n", indent, linkVisited)
		}
	}

	// Add code colors if available
	if codeBg := palette.Resolve("code-bg"); codeBg != "" {
		fmt.Fprintf(buf, "\n%s/* Code colors */\n", indent)
		fmt.Fprintf(buf, "%s--color-code-bg: %s;\n", indent, codeBg)
		if codeText := palette.Resolve("code-text"); codeText != "" {
			fmt.Fprintf(buf, "%s--color-code-text: %s;\n", indent, codeText)
		}
	}

	// Add admonition colors if available
	admonitionTypes := []string{
		"note", "info", "tip", "hint", "success",
		"warn", "warning", "caution", "important",
		"danger", "error", "bug",
		"example", "quote", "abstract",
	}

	hasAdmonitions := false
	for _, adType := range admonitionTypes {
		if palette.Resolve("admonition-"+adType+"-bg") != "" ||
			palette.Resolve("admonition-"+adType+"-border") != "" {
			hasAdmonitions = true
			break
		}
	}

	if hasAdmonitions {
		fmt.Fprintf(buf, "\n%s/* Admonition colors */\n", indent)
		for _, adType := range admonitionTypes {
			if bg := palette.Resolve("admonition-" + adType + "-bg"); bg != "" {
				fmt.Fprintf(buf, "%s--admonition-%s-bg: %s;\n", indent, adType, bg)
			}
			if border := palette.Resolve("admonition-" + adType + "-border"); border != "" {
				fmt.Fprintf(buf, "%s--admonition-%s-border: %s;\n", indent, adType, border)
			}
		}
	}
}

// getPaletteConfig extracts palette configuration from config.Extra.
// Returns the base palette name and optional light/dark overrides.
func (p *PaletteCSSPlugin) getPaletteConfig(extra map[string]interface{}) (palette, paletteLight, paletteDark string) {
	if extra == nil {
		return "", "", ""
	}

	// Check [markata-go.theme] section
	theme, ok := extra["theme"].(map[string]interface{})
	if !ok {
		return "", "", ""
	}

	// Get base palette
	if pal, ok := theme["palette"].(string); ok && pal != "" {
		palette = pal
	}

	// Get optional light override
	if pal, ok := theme["palette_light"].(string); ok && pal != "" {
		paletteLight = pal
	}

	// Get optional dark override
	if pal, ok := theme["palette_dark"].(string); ok && pal != "" {
		paletteDark = pal
	}

	return palette, paletteLight, paletteDark
}

// Priority returns the plugin priority for the write stage.
// Should run after static_assets so it can overwrite the default variables.css
func (p *PaletteCSSPlugin) Priority(stage lifecycle.Stage) int {
	if stage == lifecycle.StageWrite {
		return lifecycle.PriorityDefault // After static_assets (PriorityEarly)
	}
	return lifecycle.PriorityDefault
}

// Ensure PaletteCSSPlugin implements the required interfaces.
var (
	_ lifecycle.Plugin         = (*PaletteCSSPlugin)(nil)
	_ lifecycle.WritePlugin    = (*PaletteCSSPlugin)(nil)
	_ lifecycle.PriorityPlugin = (*PaletteCSSPlugin)(nil)
)
