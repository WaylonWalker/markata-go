package plugins

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"

	"github.com/WaylonWalker/markata-go/pkg/lifecycle"
	"github.com/WaylonWalker/markata-go/pkg/models"
	"github.com/WaylonWalker/markata-go/pkg/palettes"
)

// PaletteCSSPlugin generates CSS variables from the configured color palette.
// It runs during the Write stage and creates/overwrites css/variables.css
// with the palette's CSS custom properties. It runs after static_assets
// to overwrite the default variables.css with palette-specific values.
//
// The plugin supports intelligent light/dark palette mapping:
// - palette = "everforest" will auto-detect everforest-light and everforest-dark
// - palette_light and palette_dark can override the auto-detected variants
//
// The plugin maps palette colors to the theme's expected CSS variable names,
// preserving fonts, spacing, and other non-color variables from the default theme.
type PaletteCSSPlugin struct{}

// NewPaletteCSSPlugin creates a new PaletteCSSPlugin.
func NewPaletteCSSPlugin() *PaletteCSSPlugin {
	return &PaletteCSSPlugin{}
}

// Name returns the unique name of the plugin.
func (p *PaletteCSSPlugin) Name() string {
	return "palette_css"
}

// Write generates CSS from the configured palette and writes it to the output directory.
func (p *PaletteCSSPlugin) Write(m *lifecycle.Manager) error {
	config := m.Config()
	outputDir := config.OutputDir

	// Get palette configuration from config.Extra["theme"]
	paletteName, paletteLight, paletteDark := p.getPaletteConfig(config.Extra)
	if paletteName == "" {
		// No palette configured, skip
		return nil
	}

	// Get effective light and dark palette names
	lightName, darkName := palettes.GetEffectivePalettes(paletteName, paletteLight, paletteDark)

	// Load palettes
	loader := palettes.NewLoader()

	var lightPalette, darkPalette *palettes.Palette
	var err error

	// Load light palette
	if lightName != "" {
		lightPalette, err = loader.Load(lightName)
		if err != nil {
			// Fall back to base palette
			lightPalette, err = loader.Load(paletteName)
			if err != nil {
				return fmt.Errorf("loading light palette %q: %w", lightName, err)
			}
		}
	}

	// Load dark palette
	if darkName != "" {
		darkPalette, err = loader.Load(darkName)
		if err != nil {
			// Fall back to base palette
			darkPalette, err = loader.Load(paletteName)
			if err != nil {
				return fmt.Errorf("loading dark palette %q: %w", darkName, err)
			}
		}
	}

	// If we have no palettes loaded, try to load the base palette
	if lightPalette == nil && darkPalette == nil {
		palette, err := loader.Load(paletteName)
		if err != nil {
			return fmt.Errorf("loading palette %q: %w", paletteName, err)
		}
		lightPalette = palette
		darkPalette = palette
	}

	// Generate theme-compatible CSS with both variants
	css := p.generateThemeCSSWithVariants(lightPalette, darkPalette, lightName, darkName)

	// Write to output directory
	cssDir := filepath.Join(outputDir, "css")
	if err := os.MkdirAll(cssDir, 0o755); err != nil {
		return fmt.Errorf("creating css directory: %w", err)
	}

	cssPath := filepath.Join(cssDir, "variables.css")
	//nolint:gosec // G306: variables.css is a public CSS file, 0644 is appropriate
	if err := os.WriteFile(cssPath, []byte(css), 0o644); err != nil {
		return fmt.Errorf("writing palette CSS: %w", err)
	}

	return nil
}

// generateThemeCSSWithVariants generates CSS with both light and dark palette variants.
// The CSS uses data-theme attribute for switching between variants.
// It preserves all non-color variables (typography, spacing, layout, gradients) from the default theme.
func (p *PaletteCSSPlugin) generateThemeCSSWithVariants(lightPalette, darkPalette *palettes.Palette, lightName, darkName string) string {
	var buf bytes.Buffer

	// Header comment
	buf.WriteString("/* CSS Custom Properties - Generated by markata-go */\n")
	buf.WriteString(fmt.Sprintf("/* Light: %s, Dark: %s */\n\n", lightName, darkName))

	// Generate palette info CSS custom properties for JavaScript
	buf.WriteString("/* Palette configuration for JavaScript theme toggle */\n")
	buf.WriteString(":root {\n")
	// CSS custom property values need the quotes as part of the value for JS to read
	buf.WriteString(fmt.Sprintf("  --palette-light: %q;\n", lightName))
	buf.WriteString(fmt.Sprintf("  --palette-dark: %q;\n", darkName))

	// Write non-color variables (typography, spacing, layout, gradients)
	// These are written once in :root and don't change between light/dark modes
	p.writeNonColorVariables(&buf, "  ")
	buf.WriteString("}\n\n")

	// Generate light mode (default) styles
	if lightPalette != nil {
		buf.WriteString(fmt.Sprintf("/* Light mode - %s */\n", lightPalette.Name))
		buf.WriteString(":root,\n")
		buf.WriteString("[data-theme=\"light\"] {\n")
		p.writePaletteVariables(&buf, lightPalette)
		buf.WriteString("}\n\n")
	}

	// Generate dark mode styles
	if darkPalette != nil {
		buf.WriteString(fmt.Sprintf("/* Dark mode - %s */\n", darkPalette.Name))
		buf.WriteString("[data-theme=\"dark\"] {\n")
		p.writePaletteVariables(&buf, darkPalette)
		buf.WriteString("}\n\n")

		// Also add prefers-color-scheme media query for auto mode
		buf.WriteString("/* Auto dark mode based on system preference */\n")
		buf.WriteString("@media (prefers-color-scheme: dark) {\n")
		buf.WriteString("  :root:not([data-theme=\"light\"]) {\n")
		p.writePaletteVariablesIndented(&buf, darkPalette, "    ")
		buf.WriteString("  }\n")
		buf.WriteString("}\n")
	}

	return buf.String()
}

// writePaletteVariables writes CSS custom properties for a palette.
func (p *PaletteCSSPlugin) writePaletteVariables(buf *bytes.Buffer, palette *palettes.Palette) {
	p.writePaletteVariablesIndented(buf, palette, "  ")
}

// writeNonColorVariables writes non-color CSS custom properties (typography, spacing, layout, gradients).
// These are preserved from the default theme when applying a color palette.
func (p *PaletteCSSPlugin) writeNonColorVariables(buf *bytes.Buffer, indent string) {
	// Gradients - used for media borders and highlights
	fmt.Fprintf(buf, "\n%s/* Accent gradients */\n", indent)
	fmt.Fprintf(buf, "%s--gradient-accent: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark));\n", indent)
	fmt.Fprintf(buf, "%s--gradient-vibrant: linear-gradient(135deg, #667eea, #764ba2, #f093fb);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-warm: linear-gradient(135deg, #f093fb, #f5576c, #f8b500);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-cool: linear-gradient(135deg, #4facfe, #00f2fe);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-sunset: linear-gradient(135deg, #fa709a, #fee140);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-ocean: linear-gradient(135deg, #2193b0, #6dd5ed);\n", indent)

	// Palette-specific gradients
	fmt.Fprintf(buf, "\n%s/* Palette-specific gradients */\n", indent)
	fmt.Fprintf(buf, "%s--gradient-catppuccin: linear-gradient(135deg, #cba6f7, #f5c2e7, #f38ba8);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-nord: linear-gradient(135deg, #88c0d0, #81a1c1, #5e81ac);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-dracula: linear-gradient(135deg, #bd93f9, #ff79c6, #8be9fd);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-gruvbox: linear-gradient(135deg, #fabd2f, #fe8019, #fb4934);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-rose-pine: linear-gradient(135deg, #c4a7e7, #ebbcba, #f6c177);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-solarized: linear-gradient(135deg, #268bd2, #2aa198, #859900);\n", indent)
	fmt.Fprintf(buf, "%s--gradient-tokyo-night: linear-gradient(135deg, #7aa2f7, #bb9af7, #f7768e);\n", indent)

	// Media border settings
	fmt.Fprintf(buf, "\n%s/* Media border settings */\n", indent)
	fmt.Fprintf(buf, "%s--media-border-width: 3px;\n", indent)
	fmt.Fprintf(buf, "%s--media-border-style: solid;\n", indent)
	fmt.Fprintf(buf, "%s--media-border-color: var(--color-border);\n", indent)
	fmt.Fprintf(buf, "%s--media-border-gradient: none;\n", indent)
	fmt.Fprintf(buf, "%s--media-border-radius: var(--radius-lg);\n", indent)

	// Font families
	fmt.Fprintf(buf, "\n%s/* Font families */\n", indent)
	fmt.Fprintf(buf, "%s--font-body: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n", indent)
	fmt.Fprintf(buf, "%s--font-heading: var(--font-body);\n", indent)
	fmt.Fprintf(buf, "%s--font-mono: ui-monospace, 'Cascadia Code', 'Fira Code', 'JetBrains Mono', Consolas, monospace;\n", indent)

	// Font sizes (modular scale)
	fmt.Fprintf(buf, "\n%s/* Font sizes */\n", indent)
	fmt.Fprintf(buf, "%s--text-xs: 0.75rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-sm: 0.875rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-base: 1rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-lg: 1.125rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-xl: 1.25rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-2xl: 1.5rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-3xl: 1.875rem;\n", indent)
	fmt.Fprintf(buf, "%s--text-4xl: 2.25rem;\n", indent)

	// Line heights
	fmt.Fprintf(buf, "\n%s/* Line heights */\n", indent)
	fmt.Fprintf(buf, "%s--leading-tight: 1.25;\n", indent)
	fmt.Fprintf(buf, "%s--leading-normal: 1.5;\n", indent)
	fmt.Fprintf(buf, "%s--leading-relaxed: 1.75;\n", indent)

	// Spacing scale
	fmt.Fprintf(buf, "\n%s/* Spacing scale */\n", indent)
	fmt.Fprintf(buf, "%s--space-1: 0.25rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-2: 0.5rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-3: 0.75rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-4: 1rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-6: 1.5rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-8: 2rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-12: 3rem;\n", indent)
	fmt.Fprintf(buf, "%s--space-16: 4rem;\n", indent)

	// Layout
	fmt.Fprintf(buf, "\n%s/* Layout */\n", indent)
	fmt.Fprintf(buf, "%s--content-width: 65ch;\n", indent)
	fmt.Fprintf(buf, "%s--page-width: 1200px;\n", indent)
	fmt.Fprintf(buf, "%s--radius: 0.375rem;\n", indent)
	fmt.Fprintf(buf, "%s--radius-lg: 0.5rem;\n", indent)
}

// writePaletteVariablesIndented writes CSS custom properties with custom indentation.
//
//nolint:gocyclo // complexity is acceptable for a CSS generation function with many rules
func (p *PaletteCSSPlugin) writePaletteVariablesIndented(buf *bytes.Buffer, palette *palettes.Palette, indent string) {
	// Primary/accent colors
	if accent := palette.Resolve("accent"); accent != "" {
		fmt.Fprintf(buf, "%s--color-primary: %s;\n", indent, accent)
	}
	if accentHover := palette.Resolve("accent-hover"); accentHover != "" {
		fmt.Fprintf(buf, "%s--color-primary-light: %s;\n", indent, accentHover)
		fmt.Fprintf(buf, "%s--color-primary-dark: %s;\n", indent, accentHover)
	}

	fmt.Fprintf(buf, "\n%s/* Semantic colors */\n", indent)

	// Text colors
	if textPrimary := palette.Resolve("text-primary"); textPrimary != "" {
		fmt.Fprintf(buf, "%s--color-text: %s;\n", indent, textPrimary)
	}
	if textMuted := palette.Resolve("text-muted"); textMuted != "" {
		fmt.Fprintf(buf, "%s--color-text-muted: %s;\n", indent, textMuted)
	}

	// Background colors
	if bgPrimary := palette.Resolve("bg-primary"); bgPrimary != "" {
		fmt.Fprintf(buf, "%s--color-background: %s;\n", indent, bgPrimary)
	}
	if bgSurface := palette.Resolve("bg-surface"); bgSurface != "" {
		fmt.Fprintf(buf, "%s--color-surface: %s;\n", indent, bgSurface)
	}

	// Border
	if border := palette.Resolve("border"); border != "" {
		fmt.Fprintf(buf, "%s--color-border: %s;\n", indent, border)
	}

	fmt.Fprintf(buf, "\n%s/* Status colors */\n", indent)

	// Status colors
	if success := palette.Resolve("success"); success != "" {
		fmt.Fprintf(buf, "%s--color-success: %s;\n", indent, success)
	}
	if warning := palette.Resolve("warning"); warning != "" {
		fmt.Fprintf(buf, "%s--color-warning: %s;\n", indent, warning)
	}
	if errorColor := palette.Resolve("error"); errorColor != "" {
		fmt.Fprintf(buf, "%s--color-error: %s;\n", indent, errorColor)
	}
	if info := palette.Resolve("info"); info != "" {
		fmt.Fprintf(buf, "%s--color-info: %s;\n", indent, info)
	}

	// Add link colors if available
	if link := palette.Resolve("link"); link != "" {
		fmt.Fprintf(buf, "\n%s/* Link colors */\n", indent)
		fmt.Fprintf(buf, "%s--color-link: %s;\n", indent, link)
		if linkHover := palette.Resolve("link-hover"); linkHover != "" {
			fmt.Fprintf(buf, "%s--color-link-hover: %s;\n", indent, linkHover)
		}
		if linkVisited := palette.Resolve("link-visited"); linkVisited != "" {
			fmt.Fprintf(buf, "%s--color-link-visited: %s;\n", indent, linkVisited)
		}
	}

	// Add code colors if available
	if codeBg := palette.Resolve("code-bg"); codeBg != "" {
		fmt.Fprintf(buf, "\n%s/* Code colors */\n", indent)
		fmt.Fprintf(buf, "%s--color-code-bg: %s;\n", indent, codeBg)
		if codeText := palette.Resolve("code-text"); codeText != "" {
			fmt.Fprintf(buf, "%s--color-code-text: %s;\n", indent, codeText)
		}
	}

	// Add admonition colors if available
	admonitionTypes := []string{
		"note", "info", "tip", "hint", "success",
		"warn", "warning", "caution", "important",
		"danger", "error", "bug",
		"example", "quote", "abstract",
	}

	hasAdmonitions := false
	for _, adType := range admonitionTypes {
		if palette.Resolve("admonition-"+adType+"-bg") != "" ||
			palette.Resolve("admonition-"+adType+"-border") != "" {
			hasAdmonitions = true
			break
		}
	}

	if hasAdmonitions {
		fmt.Fprintf(buf, "\n%s/* Admonition colors */\n", indent)
		for _, adType := range admonitionTypes {
			if bg := palette.Resolve("admonition-" + adType + "-bg"); bg != "" {
				fmt.Fprintf(buf, "%s--admonition-%s-bg: %s;\n", indent, adType, bg)
			}
			if border := palette.Resolve("admonition-" + adType + "-border"); border != "" {
				fmt.Fprintf(buf, "%s--admonition-%s-border: %s;\n", indent, adType, border)
			}
		}
	}
}

// getPaletteConfig extracts palette configuration from config.Extra.
// Returns the base palette name and optional light/dark overrides.
func (p *PaletteCSSPlugin) getPaletteConfig(extra map[string]interface{}) (palette, paletteLight, paletteDark string) {
	if extra == nil {
		return "", "", ""
	}

	// Check if theme is a models.ThemeConfig (from core.go)
	if themeConfig, ok := extra["theme"].(models.ThemeConfig); ok {
		return themeConfig.Palette, themeConfig.PaletteLight, themeConfig.PaletteDark
	}

	// Check if theme is a map[string]interface{} (from benchmark.go or raw TOML)
	theme, ok := extra["theme"].(map[string]interface{})
	if !ok {
		return "", "", ""
	}

	// Get base palette
	if pal, ok := theme["palette"].(string); ok && pal != "" {
		palette = pal
	}

	// Get optional light override
	if pal, ok := theme["palette_light"].(string); ok && pal != "" {
		paletteLight = pal
	}

	// Get optional dark override
	if pal, ok := theme["palette_dark"].(string); ok && pal != "" {
		paletteDark = pal
	}

	return palette, paletteLight, paletteDark
}

// Priority returns the plugin priority for the write stage.
// Should run after static_assets so it can overwrite the default variables.css
func (p *PaletteCSSPlugin) Priority(stage lifecycle.Stage) int {
	if stage == lifecycle.StageWrite {
		return lifecycle.PriorityDefault // After static_assets (PriorityEarly)
	}
	return lifecycle.PriorityDefault
}

// Ensure PaletteCSSPlugin implements the required interfaces.
var (
	_ lifecycle.Plugin         = (*PaletteCSSPlugin)(nil)
	_ lifecycle.WritePlugin    = (*PaletteCSSPlugin)(nil)
	_ lifecycle.PriorityPlugin = (*PaletteCSSPlugin)(nil)
)
