package plugins

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/WaylonWalker/markata-go/pkg/lifecycle"
	"github.com/WaylonWalker/markata-go/pkg/models"
)

func TestPaletteCSSPlugin_Name(t *testing.T) {
	p := NewPaletteCSSPlugin()
	if got := p.Name(); got != "palette_css" {
		t.Errorf("Name() = %q, want %q", got, "palette_css")
	}
}

func TestPaletteCSSPlugin_GetPaletteConfig_WithThemeConfig(t *testing.T) {
	p := NewPaletteCSSPlugin()

	// Test with models.ThemeConfig (as stored by core.go)
	extra := map[string]interface{}{
		"theme": models.ThemeConfig{
			Name:         "default",
			Palette:      "catppuccin-mocha",
			PaletteLight: "catppuccin-latte",
			PaletteDark:  "catppuccin-mocha",
		},
	}

	palette, paletteLight, paletteDark, _ := p.getPaletteConfig(extra)

	if palette != "catppuccin-mocha" {
		t.Errorf("palette = %q, want %q", palette, "catppuccin-mocha")
	}
	if paletteLight != "catppuccin-latte" {
		t.Errorf("paletteLight = %q, want %q", paletteLight, "catppuccin-latte")
	}
	if paletteDark != "catppuccin-mocha" {
		t.Errorf("paletteDark = %q, want %q", paletteDark, "catppuccin-mocha")
	}
}

func TestPaletteCSSPlugin_GetPaletteConfig_WithMapInterface(t *testing.T) {
	p := NewPaletteCSSPlugin()

	// Test with map[string]interface{} (as from raw TOML)
	extra := map[string]interface{}{
		"theme": map[string]interface{}{
			"name":          "default",
			"palette":       "nord",
			"palette_light": "nord-light",
			"palette_dark":  "nord",
		},
	}

	palette, paletteLight, paletteDark, _ := p.getPaletteConfig(extra)

	if palette != "nord" {
		t.Errorf("palette = %q, want %q", palette, "nord")
	}
	if paletteLight != "nord-light" {
		t.Errorf("paletteLight = %q, want %q", paletteLight, "nord-light")
	}
	if paletteDark != "nord" {
		t.Errorf("paletteDark = %q, want %q", paletteDark, "nord")
	}
}

func TestPaletteCSSPlugin_Write_GeneratesCSS(t *testing.T) {
	tmpDir := t.TempDir()

	p := NewPaletteCSSPlugin()
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
			},
		},
	})

	if err := p.Write(m); err != nil {
		t.Fatalf("Write error: %v", err)
	}

	// Check the file was created
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}

	css := string(content)

	// Verify header comment
	if !strings.Contains(css, "CSS Custom Properties - Generated by markata-go") {
		t.Error("expected header comment in CSS")
	}

	// Verify it mentions catppuccin
	if !strings.Contains(css, "catppuccin") {
		t.Error("expected catppuccin in CSS")
	}

	// Verify it has color variables
	if !strings.Contains(css, "--color-primary") {
		t.Error("expected --color-primary in CSS")
	}
}

func TestPaletteCSSPlugin_Write_AppliesThemeVariables(t *testing.T) {
	tmpDir := t.TempDir()

	p := NewPaletteCSSPlugin()
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
				Variables: map[string]string{
					"--text-base":     "1.125rem",
					"--content-width": "70ch",
				},
			},
		},
	})

	if err := p.Write(m); err != nil {
		t.Fatalf("Write error: %v", err)
	}

	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}

	css := string(content)
	if !strings.Contains(css, "--text-base: 1.125rem;") {
		t.Error("expected theme variable override for --text-base")
	}
	if !strings.Contains(css, "--content-width: 70ch;") {
		t.Error("expected theme variable override for --content-width")
	}
}

func TestPaletteCSSPlugin_Write_AppliesThemeVariablesFromModelsConfig(t *testing.T) {
	tmpDir := t.TempDir()

	modelsConfig := &models.Config{}
	modelsConfig.Theme = models.ThemeConfig{
		Name:    "default",
		Palette: "catppuccin-mocha",
		Variables: map[string]string{
			"--text-base":     "1.5rem",
			"--content-width": "72ch",
		},
	}

	p := NewPaletteCSSPlugin()
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"models_config": modelsConfig,
		},
	})

	if err := p.Write(m); err != nil {
		t.Fatalf("Write error: %v", err)
	}

	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}

	css := string(content)
	if !strings.Contains(css, "--text-base: 1.5rem;") {
		t.Error("expected theme variable override from models_config for --text-base")
	}
	if !strings.Contains(css, "--content-width: 72ch;") {
		t.Error("expected theme variable override from models_config for --content-width")
	}
}

func TestPaletteCSSPlugin_Write_NoPaletteSkips(t *testing.T) {
	tmpDir := t.TempDir()

	p := NewPaletteCSSPlugin()
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name: "default",
				// No palette set
			},
		},
	})

	if err := p.Write(m); err != nil {
		t.Fatalf("Write error: %v", err)
	}

	// File should NOT be created when no palette is configured
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	if _, err := os.Stat(cssPath); err == nil {
		t.Error("expected palette.css to NOT be created when no palette is configured")
	}
}

// TestPaletteCSSPlugin_ServeMode_ConfigChange simulates the serve mode scenario
// where palette config changes should be detected and new CSS should be generated.
func TestPaletteCSSPlugin_ServeMode_ConfigChange(t *testing.T) {
	tmpDir := t.TempDir()

	// First build with catppuccin-mocha
	p1 := NewPaletteCSSPlugin()
	m1 := lifecycle.NewManager()
	m1.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
			},
		},
	})

	if err := p1.Write(m1); err != nil {
		t.Fatalf("First Write error: %v", err)
	}

	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content1, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css after first build: %v", err)
	}

	css1 := string(content1)
	if !strings.Contains(css1, "catppuccin-mocha") {
		t.Errorf("First build should contain catppuccin-mocha, got:\n%s", css1[:min(500, len(css1))])
	}

	// Second build with dracula - simulates user changing config
	p2 := NewPaletteCSSPlugin()
	m2 := lifecycle.NewManager()
	m2.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "dracula",
			},
		},
	})

	if err := p2.Write(m2); err != nil {
		t.Fatalf("Second Write error: %v", err)
	}

	content2, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css after second build: %v", err)
	}

	css2 := string(content2)
	if !strings.Contains(css2, "dracula") {
		t.Errorf("Second build should contain dracula, got:\n%s", css2[:min(500, len(css2))])
	}

	// Verify the CSS actually changed
	if css1 == css2 {
		t.Error("CSS should have changed between builds with different palettes")
	}
}

func TestPaletteCSSPlugin_Priority(t *testing.T) {
	p := NewPaletteCSSPlugin()

	// Should have default priority for write stage (runs after static_assets)
	if got := p.Priority(lifecycle.StageWrite); got != lifecycle.PriorityDefault {
		t.Errorf("Priority(StageWrite) = %d, want %d", got, lifecycle.PriorityDefault)
	}
}

// TestPaletteCSSPlugin_FullBuildFlow simulates the full build flow with
// static_assets running before palette_css to verify palette CSS overwrites defaults.
func TestPaletteCSSPlugin_FullBuildFlow(t *testing.T) {
	tmpDir := t.TempDir()

	// Setup: Create a manager with both plugins
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
			},
		},
	})

	// Step 1: Run static_assets (writes default palette.css)
	staticPlugin := NewStaticAssetsPlugin()
	if err := staticPlugin.Write(m); err != nil {
		t.Fatalf("StaticAssetsPlugin.Write error: %v", err)
	}

	// Step 2: Run palette_css (should overwrite with catppuccin)
	palettePlugin := NewPaletteCSSPlugin()
	m.SetAssetHash("css/palette.css", "deadbeef")
	if err := palettePlugin.Write(m); err != nil {
		t.Fatalf("PaletteCSSPlugin.Write error: %v", err)
	}

	// Verify: CSS should have catppuccin colors, not defaults
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}

	css := string(content)

	// Should have catppuccin-mocha in the header
	if !strings.Contains(css, "catppuccin-mocha") {
		t.Error("expected catppuccin-mocha in CSS header")
	}

	// Should have "Generated by markata-go" header (from palette_css, not default)
	if !strings.Contains(css, "CSS Custom Properties - Generated by markata-go") {
		t.Error("expected Generated by markata-go in CSS header")
	}

	hashedPath := filepath.Join(tmpDir, "css", "palette.deadbeef.css")
	if _, err := os.Stat(hashedPath); err != nil {
		t.Fatalf("expected hashed palette.css to exist: %v", err)
	}
}

// TestPaletteCSSPlugin_FullBuildFlow_NoPalette tests that when no palette is configured,
// the default CSS from static_assets is preserved.
func TestPaletteCSSPlugin_FullBuildFlow_NoPalette(t *testing.T) {
	tmpDir := t.TempDir()

	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name: "default",
				// No Palette set
			},
		},
	})

	// Step 1: Run static_assets
	staticPlugin := NewStaticAssetsPlugin()
	if err := staticPlugin.Write(m); err != nil {
		t.Fatalf("StaticAssetsPlugin.Write error: %v", err)
	}

	// Check if default CSS exists
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	_, err := os.Stat(cssPath)
	defaultExists := err == nil

	// Step 2: Run palette_css (should skip since no palette)
	palettePlugin := NewPaletteCSSPlugin()
	if err := palettePlugin.Write(m); err != nil {
		t.Fatalf("PaletteCSSPlugin.Write error: %v", err)
	}

	// If default existed, verify it's still there and unmodified (or modified by palette_css is fine too)
	if defaultExists {
		content, err := os.ReadFile(cssPath)
		if err != nil {
			t.Fatalf("failed to read palette.css: %v", err)
		}
		// Just verify it's not empty
		if len(content) == 0 {
			t.Error("palette.css should not be empty")
		}
	}
}
