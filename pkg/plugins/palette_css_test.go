package plugins

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/WaylonWalker/markata-go/pkg/lifecycle"
	"github.com/WaylonWalker/markata-go/pkg/models"
)

func TestPaletteCSSPlugin_Name(t *testing.T) {
	p := NewPaletteCSSPlugin()
	if got := p.Name(); got != "palette_css" {
		t.Errorf("Name() = %q, want %q", got, "palette_css")
	}
}

func TestPaletteCSSPlugin_GetPaletteConfig_WithThemeConfig(t *testing.T) {
	p := NewPaletteCSSPlugin()

	// Test with models.ThemeConfig (as stored by core.go)
	extra := map[string]interface{}{
		"theme": models.ThemeConfig{
			Name:         "default",
			Palette:      "catppuccin-mocha",
			PaletteLight: "catppuccin-latte",
			PaletteDark:  "catppuccin-mocha",
		},
	}

	palette, paletteLight, paletteDark := p.getPaletteConfig(extra)

	if palette != "catppuccin-mocha" {
		t.Errorf("palette = %q, want %q", palette, "catppuccin-mocha")
	}
	if paletteLight != "catppuccin-latte" {
		t.Errorf("paletteLight = %q, want %q", paletteLight, "catppuccin-latte")
	}
	if paletteDark != "catppuccin-mocha" {
		t.Errorf("paletteDark = %q, want %q", paletteDark, "catppuccin-mocha")
	}
}

func TestPaletteCSSPlugin_GetPaletteConfig_WithMapInterface(t *testing.T) {
	p := NewPaletteCSSPlugin()

	// Test with map[string]interface{} (as from raw TOML)
	extra := map[string]interface{}{
		"theme": map[string]interface{}{
			"name":          "default",
			"palette":       "nord",
			"palette_light": "nord-light",
			"palette_dark":  "nord",
		},
	}

	palette, paletteLight, paletteDark := p.getPaletteConfig(extra)

	if palette != "nord" {
		t.Errorf("palette = %q, want %q", palette, "nord")
	}
	if paletteLight != "nord-light" {
		t.Errorf("paletteLight = %q, want %q", paletteLight, "nord-light")
	}
	if paletteDark != "nord" {
		t.Errorf("paletteDark = %q, want %q", paletteDark, "nord")
	}
}

func TestPaletteCSSPlugin_Write_GeneratesCSS(t *testing.T) {
	tmpDir := t.TempDir()

	p := NewPaletteCSSPlugin()
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
			},
		},
	})

	if err := p.Write(m); err != nil {
		t.Fatalf("Write error: %v", err)
	}

	// Check the file was created
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}

	css := string(content)

	// Verify header comment
	if !strings.Contains(css, "CSS Custom Properties - Generated by markata-go") {
		t.Error("expected header comment in CSS")
	}

	// Verify it mentions catppuccin
	if !strings.Contains(css, "catppuccin") {
		t.Error("expected catppuccin in CSS")
	}

	// Verify it has color variables
	if !strings.Contains(css, "--color-primary") {
		t.Error("expected --color-primary in CSS")
	}
}

func TestPaletteCSSPlugin_Write_NoPaletteSkips(t *testing.T) {
	tmpDir := t.TempDir()

	p := NewPaletteCSSPlugin()
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name: "default",
				// No palette set
			},
		},
	})

	if err := p.Write(m); err != nil {
		t.Fatalf("Write error: %v", err)
	}

	// A minimal palette.css is created even when no palette is configured.
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}
	if !strings.Contains(string(content), "--palette-switcher-enabled") {
		t.Error("expected palette switcher flag in palette.css")
	}
}

// TestPaletteCSSPlugin_ServeMode_ConfigChange simulates the serve mode scenario
// where palette config changes should be detected and new CSS should be generated.
func TestPaletteCSSPlugin_ServeMode_ConfigChange(t *testing.T) {
	tmpDir := t.TempDir()

	// First build with catppuccin-mocha
	p1 := NewPaletteCSSPlugin()
	m1 := lifecycle.NewManager()
	m1.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
			},
		},
	})

	if err := p1.Write(m1); err != nil {
		t.Fatalf("First Write error: %v", err)
	}

	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content1, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css after first build: %v", err)
	}

	css1 := string(content1)
	if !strings.Contains(css1, "catppuccin-mocha") {
		t.Errorf("First build should contain catppuccin-mocha, got:\n%s", css1[:min(500, len(css1))])
	}

	// Second build with dracula - simulates user changing config
	p2 := NewPaletteCSSPlugin()
	m2 := lifecycle.NewManager()
	m2.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "dracula",
			},
		},
	})

	if err := p2.Write(m2); err != nil {
		t.Fatalf("Second Write error: %v", err)
	}

	content2, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css after second build: %v", err)
	}

	css2 := string(content2)
	if !strings.Contains(css2, "dracula") {
		t.Errorf("Second build should contain dracula, got:\n%s", css2[:min(500, len(css2))])
	}

	// Verify the CSS actually changed
	if css1 == css2 {
		t.Error("CSS should have changed between builds with different palettes")
	}
}

func TestPaletteCSSPlugin_Priority(t *testing.T) {
	p := NewPaletteCSSPlugin()

	// Should have default priority for write stage (runs after static_assets)
	if got := p.Priority(lifecycle.StageWrite); got != lifecycle.PriorityDefault {
		t.Errorf("Priority(StageWrite) = %d, want %d", got, lifecycle.PriorityDefault)
	}
}

// TestPaletteCSSPlugin_FullBuildFlow simulates the full build flow with
// static_assets running before palette_css to verify palette CSS overwrites defaults.
func TestPaletteCSSPlugin_FullBuildFlow(t *testing.T) {
	tmpDir := t.TempDir()

	// Setup: Create a manager with both plugins
	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name:    "default",
				Palette: "catppuccin-mocha",
			},
		},
	})

	// Step 1: Run static_assets (writes default variables.css)
	staticPlugin := NewStaticAssetsPlugin()
	if err := staticPlugin.Write(m); err != nil {
		t.Fatalf("StaticAssetsPlugin.Write error: %v", err)
	}

	// Step 2: Run palette_css (writes palette.css with catppuccin)
	palettePlugin := NewPaletteCSSPlugin()
	if err := palettePlugin.Write(m); err != nil {
		t.Fatalf("PaletteCSSPlugin.Write error: %v", err)
	}

	// Verify: variables.css still exists (theme identity tokens)
	variablesPath := filepath.Join(tmpDir, "css", "variables.css")
	if _, err := os.Stat(variablesPath); err != nil {
		t.Fatalf("expected variables.css to exist: %v", err)
	}

	// Verify: palette.css contains catppuccin colors
	cssPath := filepath.Join(tmpDir, "css", "palette.css")
	content, err := os.ReadFile(cssPath)
	if err != nil {
		t.Fatalf("failed to read palette.css: %v", err)
	}

	css := string(content)

	// Should have catppuccin-mocha in the header
	if !strings.Contains(css, "catppuccin-mocha") {
		t.Error("expected catppuccin-mocha in CSS header")
	}

	// Should have "Generated by markata-go" header
	if !strings.Contains(css, "CSS Custom Properties - Generated by markata-go") {
		t.Error("expected Generated by markata-go in CSS header")
	}
}

// TestPaletteCSSPlugin_FullBuildFlow_NoPalette tests that when no palette is configured,
// the default CSS from static_assets is preserved.
func TestPaletteCSSPlugin_FullBuildFlow_NoPalette(t *testing.T) {
	tmpDir := t.TempDir()

	m := lifecycle.NewManager()
	m.SetConfig(&lifecycle.Config{
		OutputDir: tmpDir,
		Extra: map[string]interface{}{
			"theme": models.ThemeConfig{
				Name: "default",
				// No Palette set
			},
		},
	})

	// Step 1: Run static_assets
	staticPlugin := NewStaticAssetsPlugin()
	if err := staticPlugin.Write(m); err != nil {
		t.Fatalf("StaticAssetsPlugin.Write error: %v", err)
	}

	// Check if default variables.css exists
	variablesPath := filepath.Join(tmpDir, "css", "variables.css")
	_, err := os.Stat(variablesPath)
	defaultExists := err == nil

	// Step 2: Run palette_css (should skip since no palette)
	palettePlugin := NewPaletteCSSPlugin()
	if err := palettePlugin.Write(m); err != nil {
		t.Fatalf("PaletteCSSPlugin.Write error: %v", err)
	}

	// If default existed, verify it's still there
	if defaultExists {
		content, err := os.ReadFile(variablesPath)
		if err != nil {
			t.Fatalf("failed to read variables.css: %v", err)
		}
		// Just verify it's not empty
		if len(content) == 0 {
			t.Error("variables.css should not be empty")
		}
	}

	// palette.css exists (minimal) even when no palette is configured
	palettePath := filepath.Join(tmpDir, "css", "palette.css")
	if _, err := os.Stat(palettePath); err != nil {
		t.Fatalf("expected palette.css to exist: %v", err)
	}
}
