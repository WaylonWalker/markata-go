{% if graph_json and post and post.href %}
<section class="post-graph" data-graph="{{ graph_json }}" data-post="{{ post.href }}">
  <div class="post-graph__header">
    <div>
      <h2>Connections</h2>
      <p class="post-graph__description">Related tags and posts connected to this entry.</p>
    </div>
    <div class="post-graph__controls">
      <label class="post-graph__control">
        <span>Nodes</span>
        <input type="range" class="post-graph__limit" min="8" max="120" step="2" value="100" data-default="100" />
        <span class="post-graph__limit-value">100</span>
      </label>
      <label class="post-graph__toggle">
        <input type="checkbox" class="post-graph__animate" checked />
        <span>Animate</span>
      </label>
      <label class="post-graph__toggle">
        <input type="checkbox" class="post-graph__labels" />
        <span>Labels</span>
      </label>
    </div>
  </div>
  <div class="post-graph__canvas">
    <canvas class="post-graph__canvas-el" aria-label="Post connections graph"></canvas>
    <div class="post-graph__tooltip" aria-live="polite"></div>
  </div>
</section>

<style>
.post-graph {
  margin: var(--space-8, 2rem) 0 var(--space-6, 1.5rem);
  padding: var(--space-4, 1rem);
  border-radius: var(--radius-lg, 0.5rem);
  background: var(--color-background, #1a1a1a);
}

.post-graph__header {
  display: flex;
  justify-content: space-between;
  gap: var(--space-3, 0.75rem);
  flex-wrap: wrap;
  align-items: flex-start;
  margin-bottom: var(--space-3, 0.75rem);
}

.post-graph__header h2 {
  margin-bottom: var(--space-1, 0.25rem);
}

.post-graph__description {
  color: var(--garden-muted, #999);
  font-size: var(--text-sm, 0.875rem);
  max-width: 40ch;
}

.post-graph__controls {
  display: flex;
  gap: var(--space-2, 0.5rem);
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
}

.post-graph__control {
  display: inline-flex;
  align-items: center;
  gap: var(--space-2, 0.5rem);
  font-size: var(--text-xs, 0.75rem);
  color: var(--garden-muted, #999);
  border: 1px solid var(--garden-border, #444);
  padding: 0.25rem 0.5rem;
  border-radius: 999px;
  background: var(--color-background, #1a1a1a);
}

.post-graph__control input[type="range"] {
  accent-color: var(--garden-accent, #ffcd11);
}

.post-graph__toggle {
  display: inline-flex;
  align-items: center;
  gap: var(--space-1, 0.25rem);
  font-size: var(--text-xs, 0.75rem);
  color: var(--garden-muted, #999);
  border: 1px solid var(--garden-border, #444);
  padding: 0.25rem 0.5rem;
  border-radius: 999px;
  background: var(--color-background, #1a1a1a);
}

.post-graph__toggle input {
  accent-color: var(--garden-accent, #ffcd11);
}

.post-graph__canvas {
  position: relative;
  height: clamp(280px, 45vw, 420px);
  border-radius: 20px;
  background: var(--color-background, #1a1a1a);
  overflow: hidden;
}

.post-graph__canvas canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.post-graph__tooltip {
  position: absolute;
  pointer-events: none;
  opacity: 0;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  font-size: 0.7rem;
  padding: 0.25rem 0.5rem;
  border-radius: 0.35rem;
  transform: translate(-50%, -120%);
  transition: opacity 0.1s ease;
  white-space: nowrap;
}

@media (max-width: 600px) {
  .post-graph__canvas {
    height: 60vw;
  }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  function loadD3(callback) {
    if (window.d3) {
      callback();
      return;
    }
    var script = document.createElement('script');
    script.src = '{% if config.Extra.asset_urls.d3 %}{{ config.Extra.asset_urls.d3 }}{% else %}https://d3js.org/d3.v7.min.js{% endif %}';
    script.onload = callback;
    document.body.appendChild(script);
  }

  var sections = document.querySelectorAll('.post-graph');
  if (!sections.length) return;

  loadD3(function() {
    sections.forEach(function(section) {
      var graphUrl = section.dataset.graph;
      var postHref = section.dataset.post;
      var canvas = section.querySelector('.post-graph__canvas-el');
      var tooltip = section.querySelector('.post-graph__tooltip');
      var limitInput = section.querySelector('.post-graph__limit');
      var limitValue = section.querySelector('.post-graph__limit-value');
      var animateToggle = section.querySelector('.post-graph__animate');
      var labelsToggle = section.querySelector('.post-graph__labels');
      var ctx = canvas ? canvas.getContext('2d') : null;
      var graphData = null;
      var nodes = [];
      var edges = [];
      var simulation = null;
      var width = 0;
      var height = 0;
      var hoveredNode = null;
      var dragNode = null;
      var panX = 0;
      var panY = 0;
      var zoom = 1;
      var rebuildTimer = null;
      var prefersReducedMotion = window.matchMedia ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
      var hideSliderBelow = 24;
      var styles = getComputedStyle(section);
      var accentColor = styles.getPropertyValue('--garden-accent').trim() || '#ffcd11';
      var mutedColor = styles.getPropertyValue('--garden-muted').trim() || '#999';

      function resizeCanvas() {
        if (!canvas || !ctx) return;
        var rect = canvas.parentElement.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        var dpr = Math.min(window.devicePixelRatio || 1, 1.5);
        canvas.width = Math.max(1, Math.floor(width * dpr));
        canvas.height = Math.max(1, Math.floor(height * dpr));
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        draw();
      }

      function filterToPost(graph) {
        var postId = null;
        var hrefMap = new Map();
        graph.nodes.forEach(function(node) {
          if (node.href) {
            hrefMap.set(node.href, node.id);
          }
        });
        if (hrefMap.has(postHref)) {
          postId = hrefMap.get(postHref);
        }
        if (!postId) return { nodes: [], edges: [], postId: null };

        var connected = new Set([postId]);
        graph.edges.forEach(function(edge) {
          if (edge.source === postId) connected.add(edge.target);
          if (edge.target === postId) connected.add(edge.source);
        });

        var nodeList = graph.nodes.filter(function(node) { return connected.has(node.id); });
        var edgeList = graph.edges.filter(function(edge) {
          return connected.has(edge.source) && connected.has(edge.target);
        });

        return { nodes: nodeList, edges: edgeList, postId: postId };
      }

      function buildPreview(limit) {
        if (!graphData) return;
        var subset = filterToPost(graphData);
        if (!subset.postId) {
          section.style.display = 'none';
          return;
        }
        var currentPost = subset.nodes.find(function(node) { return node.id === subset.postId; });
        if (!currentPost) {
          section.style.display = 'none';
          return;
        }
        var connectedNodes = subset.nodes.filter(function(node) { return node.id !== subset.postId; });
        var totalConnections = connectedNodes.length;
        connectedNodes.sort(function(a, b) {
          var aScore = a.type === 'tag' ? (a.count || 0) * 1000 : (Date.parse(a.date || '') || 0);
          var bScore = b.type === 'tag' ? (b.count || 0) * 1000 : (Date.parse(b.date || '') || 0);
          return bScore - aScore;
        });
        var effectiveLimit = limit;
        if (limitInput) {
          var minValue = parseInt(limitInput.min, 10);
          var maxValue = Math.max(minValue, totalConnections);
          if (!limitInput.dataset.defaultSet) {
            var rawDefault = limitInput.dataset.default;
            if (rawDefault === 'auto') {
              effectiveLimit = totalConnections;
            } else if (rawDefault) {
              var parsedDefault = parseInt(rawDefault, 10);
              if (!isNaN(parsedDefault)) {
                effectiveLimit = parsedDefault;
              }
            }
            limitInput.dataset.defaultSet = 'true';
          }
          effectiveLimit = Math.max(minValue, Math.min(effectiveLimit, maxValue));
          limitInput.max = String(maxValue);
          if (parseInt(limitInput.value, 10) !== effectiveLimit) {
            limitInput.value = String(effectiveLimit);
          }
          if (limitValue) {
            limitValue.textContent = String(effectiveLimit);
          }
          var control = limitInput.closest('.post-graph__control') || limitInput.parentElement;
          if (control) {
            var shouldHide = totalConnections < hideSliderBelow;
            control.hidden = shouldHide;
            control.style.display = shouldHide ? 'none' : '';
          }
        }

        var cappedLimit = Math.min(effectiveLimit, totalConnections);
        var limitedNodes = connectedNodes.slice(0, cappedLimit);
        var keep = new Set(limitedNodes.map(function(node) { return node.id; }));
        keep.add(currentPost.id);

        nodes = subset.nodes.filter(function(node) { return keep.has(node.id); }).map(function(node) {
          return {
            id: node.id,
            label: node.label,
            count: node.count || 1,
            href: node.href,
            type: node.type,
            x: width / 2,
            y: height / 2,
            vx: 0,
            vy: 0,
            r: node.type === 'tag' ? 2 + Math.min(4, Math.sqrt(node.count || 1)) : 3
          };
        });

        var nodeIds = new Set(nodes.map(function(node) { return node.id; }));
        edges = subset.edges.filter(function(edge) {
          return nodeIds.has(edge.source) && nodeIds.has(edge.target);
        }).map(function(edge) {
          return {
            source: edge.source,
            target: edge.target,
            weight: edge.weight || 1,
            type: edge.type
          };
        });

        // limit control handled above

        startSimulation();
      }

      function startSimulation() {
        if (!window.d3) return;
        if (simulation) simulation.stop();
        simulation = window.d3.forceSimulation(nodes)
          .force('link', window.d3.forceLink(edges)
            .id(function(d) { return d.id; })
            .distance(function(d) { return d.type === 'co-occurrence' ? 120 : 90; })
            .strength(function(d) { return d.type === 'co-occurrence' ? 0.35 : 0.6; }))
          .force('charge', window.d3.forceManyBody().strength(-180).distanceMax(260))
          .force('center', window.d3.forceCenter(width / 2, height / 2))
          .force('collision', window.d3.forceCollide().radius(function(d) { return d.r + 6; }));

        if (animateToggle && animateToggle.checked) {
          simulation.on('tick', draw);
          simulation.alpha(1).restart();
        } else {
          simulation.on('tick', null);
          simulation.alpha(1);
          for (var i = 0; i < 160; i++) {
            simulation.tick();
          }
          simulation.stop();
          draw();
        }
      }

      function draw() {
        if (!ctx) return;
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        ctx.translate(panX, panY);
        ctx.scale(zoom, zoom);
        edges.forEach(function(edge) {
          var weight = Math.min(2, Math.max(0.4, edge.weight / 4));
          if (edge.type === 'co-occurrence') {
            ctx.lineWidth = 0.35;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
          } else {
            ctx.lineWidth = weight;
            ctx.strokeStyle = 'rgba(255, 205, 17, 0.08)';
          }
          ctx.beginPath();
          ctx.moveTo(edge.source.x, edge.source.y);
          ctx.lineTo(edge.target.x, edge.target.y);
          ctx.stroke();
        });

        nodes.forEach(function(node) {
          ctx.beginPath();
          if (node.type === 'post') {
            ctx.strokeStyle = accentColor;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.75;
            var size = node.r + 3;
            ctx.rect(node.x - size / 2, node.y - size / 2, size, size);
            ctx.stroke();
          } else {
            ctx.fillStyle = accentColor;
            ctx.globalAlpha = 0.5;
            ctx.arc(node.x, node.y, node.r, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        });

        if (labelsToggle && labelsToggle.checked) {
          ctx.fillStyle = mutedColor;
          ctx.font = '10px var(--font-display, "Space Grotesk"), ui-sans-serif, system-ui';
          nodes.forEach(function(node) {
            ctx.fillText(node.label, node.x + node.r + 4, node.y + 3);
          });
        }

        if (hoveredNode) {
          ctx.beginPath();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.2;
          if (hoveredNode.type === 'post') {
            var size = hoveredNode.r + 6;
            ctx.rect(hoveredNode.x - size / 2, hoveredNode.y - size / 2, size, size);
            ctx.stroke();
          } else {
            ctx.arc(hoveredNode.x, hoveredNode.y, hoveredNode.r + 3, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
        ctx.restore();
      }

      function setTooltip(node, x, y) {
        if (!tooltip) return;
        if (!node) {
          tooltip.style.opacity = '0';
          tooltip.textContent = '';
          return;
        }
        tooltip.textContent = node.label;
        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
        tooltip.style.opacity = '1';
      }

      function findNodeAt(x, y) {
        for (var i = nodes.length - 1; i >= 0; i--) {
          var node = nodes[i];
          var dx = x - node.x;
          var dy = y - node.y;
          var radius = node.r + 4;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) {
            return node;
          }
        }
        return null;
      }

      function onPointerMove(event) {
        var rect = canvas.getBoundingClientRect();
        var x = (event.clientX - rect.left - panX) / zoom;
        var y = (event.clientY - rect.top - panY) / zoom;
        hoveredNode = findNodeAt(x, y);
        setTooltip(hoveredNode, event.clientX - rect.left, event.clientY - rect.top);
        draw();
      }

      function onPointerLeave() {
        hoveredNode = null;
        setTooltip(null);
        draw();
      }

      function onClick() {
        if (hoveredNode && hoveredNode.href) {
          window.location.href = hoveredNode.href;
        }
      }

      function onWheel(event) {
        event.preventDefault();
        var rect = canvas.getBoundingClientRect();
        var mx = event.clientX - rect.left;
        var my = event.clientY - rect.top;
        var delta = event.deltaY > 0 ? 0.92 : 1.08;
        var nextZoom = Math.max(0.4, Math.min(3, zoom * delta));
        panX = mx - (mx - panX) * (nextZoom / zoom);
        panY = my - (my - panY) * (nextZoom / zoom);
        zoom = nextZoom;
        draw();
      }

      function onPointerDown(event) {
        var rect = canvas.getBoundingClientRect();
        var x = (event.clientX - rect.left - panX) / zoom;
        var y = (event.clientY - rect.top - panY) / zoom;
        dragNode = findNodeAt(x, y);
        if (dragNode) {
          dragNode.fx = dragNode.x;
          dragNode.fy = dragNode.y;
          if (simulation) {
            simulation.alphaTarget(0.2).restart();
          }
        } else {
          dragNode = { pan: true, startX: event.clientX, startY: event.clientY, baseX: panX, baseY: panY };
        }
      }

      function onPointerMoveDrag(event) {
        if (!dragNode) return;
        if (dragNode.pan) {
          panX = dragNode.baseX + (event.clientX - dragNode.startX);
          panY = dragNode.baseY + (event.clientY - dragNode.startY);
        } else {
          var rect = canvas.getBoundingClientRect();
          dragNode.fx = (event.clientX - rect.left - panX) / zoom;
          dragNode.fy = (event.clientY - rect.top - panY) / zoom;
        }
        draw();
      }

      function onPointerUp() {
        if (dragNode && !dragNode.pan) {
          dragNode.fx = null;
          dragNode.fy = null;
          if (simulation) {
            simulation.alphaTarget(0);
          }
        }
        dragNode = null;
      }

      if (canvas) {
        canvas.addEventListener('mousemove', onPointerMove);
        canvas.addEventListener('mouseleave', onPointerLeave);
        canvas.addEventListener('click', onClick);
        canvas.addEventListener('wheel', onWheel, { passive: false });
        canvas.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMoveDrag);
        window.addEventListener('mouseup', onPointerUp);
      }

      if (limitInput) {
        limitInput.addEventListener('input', function() {
          if (limitValue) limitValue.textContent = limitInput.value;
          if (rebuildTimer) window.clearTimeout(rebuildTimer);
          rebuildTimer = window.setTimeout(rebuild, 150);
        });
      }

      if (animateToggle) {
        animateToggle.addEventListener('change', function() {
          startSimulation();
        });
      }

      if (animateToggle && prefersReducedMotion && prefersReducedMotion.matches) {
        animateToggle.checked = false;
      }

      if (prefersReducedMotion) {
        prefersReducedMotion.addEventListener('change', function(event) {
          if (animateToggle) {
            animateToggle.checked = !event.matches;
          }
          startSimulation();
        });
      }

      function rebuild() {
        if (!graphData) return;
        var limit = parseInt(limitInput ? limitInput.value : '18', 10);
        if (limitValue) limitValue.textContent = String(limit);
        buildPreview(limit);
      }

      window.addEventListener('resize', function() {
        resizeCanvas();
        rebuild();
      });

      resizeCanvas();

      if (graphUrl) {
        fetch(graphUrl)
          .then(function(resp) { return resp.json(); })
          .then(function(data) {
            graphData = data;
            rebuild();
          })
          .catch(function() {
            section.style.display = 'none';
          });
      }
    });
  });
});
</script>
{% endif %}
